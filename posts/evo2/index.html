<!DOCTYPE html>

<html lang="en">

<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="color-scheme" content="light dark">
  
  
    
  
  <meta name="description" content="An in-depth look at Evo 2, Arc Institute’s DNA foundation model—its architecture, capabilities, and implications for genomics.">

  <title>Evo 2: Arc’s DNA Foundation Model Explained</title>
  <link rel="icon" type="image/png" sizes="32x32" href="https://ratankaliani.com/img/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="https://ratankaliani.com/img/favicon-16x16.png">
  <link rel="apple-touch-icon" sizes="180x180" href="https://ratankaliani.com/img/apple-touch-icon.png">
  
  <style>

  /* light mode colors */
  body {
    --primary-color: #5871a2;
    --primary-pale-color: #5871a233;
    --primary-decoration-color: #5871a210;
    --bg-color: #ffffff;
    --text-color: #2f3030;
    --text-pale-color: #767676;
    --text-decoration-color: #a9a9a9;
    --highlight-mark-color: #5f75b020;

    --callout-note-color: #5871a2;
    --callout-tip-color: #268556;
    --callout-important-color: #885fc9;
    --callout-warning-color: #ab6632;
    --callout-caution-color: #c64e4e;
  }

  /* dark mode colors */
  body.dark {
    --primary-color: #6f8fd1;
    --primary-pale-color: #6f8fd166;
    --primary-decoration-color: #6f8fd112;
    --bg-color: #1c1c1c;
    --text-color: #c1c1c1;
    --text-pale-color: #848484;
    --text-decoration-color: #5f5f5f;
    --highlight-mark-color: #8296cb3b;

    --callout-note-color: #6f8fd1;
    --callout-tip-color: #47976f;
    --callout-important-color: #9776cd;
    --callout-warning-color: #ad7a52;
    --callout-caution-color: #d06161;
  }

  /* typography */
  body {
    --main-font: ui-sans-serif, system-ui, sans-serif, 'Apple Color Emoji', 'Segoe UI Emoji', 'Segoe UI Symbol', 'Noto Color Emoji';
    --code-font: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, 'Liberation Mono', 'Courier New', monospace;
    --homepage-max-width: 768px;
    --main-max-width: 768px;
    --avatar-size: 60px;
    --font-size: 16px;
    --line-height: 1.75;
    --img-border-radius: 0px;
    --detail-border-radius: 0px;
    --dark-mode-img-brightness: 0.75;
    --dark-mode-chart-brightness: 0.75;
    --inline-code-border-radius: 2px;
    --inline-code-bg-color: var(--primary-decoration-color);
    --block-code-border-radius: 0px;
    --block-code-border-color: var(--primary-color);
    --detail-border-color: var(--primary-color);
  }

</style>

  <link rel="stylesheet" href="https://ratankaliani.com/main.css">
  
<!-- Open Graph tags -->
<meta property="og:title" content="Evo 2: Arc’s DNA Foundation Model Explained" />

  

<meta property="og:description" content="An in-depth look at Evo 2, Arc Institute’s DNA foundation model—its architecture, capabilities, and implications for genomics." />

<meta property="og:image" content="https://ratankaliani.com/evo2/cover.png" />

<meta property="og:url" content="https://ratankaliani.com/posts/evo2/" />
<meta property="og:type" content="article" />


<link id="hl" rel="stylesheet" type="text/css" href="/hl-light.css" />



  <!-- Google tag (gtag.js) -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-H853188FH4"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-H853188FH4');
</script>
</head>

<body class="post">
  
  <script>
    const theme = sessionStorage.getItem('theme');
    const match = window.matchMedia("(prefers-color-scheme: dark)").matches
    if ((theme && theme == 'dark') || (!theme && match)) {
      document.body.classList.add('dark');
      const hl = document.querySelector('link#hl');
      if (hl) hl.href = 'https://ratankaliani.com/hl-dark.css';
    }
  </script>
  
  
<div id="wrapper">
  <div id="blank"></div>
  <aside>
    
    
    <nav>
      <ul>
        
        <li>
          <a class="h2" href="#overview">Overview</a>
          
        </li>
        
        <li>
          <a class="h2" href="#quick-primer">Quick Primer</a>
          
          <ul>
            
            <li>
              <a class="h3" href="#genome-modeling">Genome Modeling</a>
            </li>
            
            <li>
              <a class="h3" href="#bioml">BioML</a>
            </li>
            
          </ul>
          
        </li>
        
        <li>
          <a class="h2" href="#training-architecture">Training &amp; Architecture</a>
          
          <ul>
            
            <li>
              <a class="h3" href="#architecture-motivations">Architecture Motivations</a>
            </li>
            
            <li>
              <a class="h3" href="#stripedhyena-2-architecture">StripedHyena 2 Architecture</a>
            </li>
            
            <li>
              <a class="h3" href="#opengenome2-dataset">OpenGenome2 Dataset</a>
            </li>
            
          </ul>
          
        </li>
        
        <li>
          <a class="h2" href="#generating-genomic-sequences">Generating Genomic Sequences</a>
          
          <ul>
            
            <li>
              <a class="h3" href="#zero-shot-novel-sequences">Zero-Shot Novel Sequences</a>
            </li>
            
            <li>
              <a class="h3" href="#scaling-inference-time-compute">Scaling Inference-Time Compute</a>
            </li>
            
          </ul>
          
        </li>
        
        <li>
          <a class="h2" href="#evo-2-mechanistic-interpretability">Evo 2 + Mechanistic Interpretability</a>
          
          <ul>
            
            <li>
              <a class="h3" href="#steering-genomic-generation-with-features">Steering Genomic Generation with Features</a>
            </li>
            
            <li>
              <a class="h3" href="#visualizing-evo-2-s-latent-space-with-feature-activations">Visualizing Evo 2&#x27;s Latent Space with Feature Activations</a>
            </li>
            
          </ul>
          
        </li>
        
        <li>
          <a class="h2" href="#takeaways">Takeaways</a>
          
        </li>
        
      </ul>
    </nav>
    
    
    <button id="back-to-top" aria-label="back to top">
      
      <svg xmlns="http://www.w3.org/2000/svg" width="18" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="feather feather-arrow-up"><line x1="12" y1="19" x2="12" y2="5"></line><polyline points="5 12 12 5 19 12"></polyline></svg>

    </button>
    
  </aside>
  <main>
    
<header>
  <nav>
    <a href="https:&#x2F;&#x2F;ratankaliani.com&#x2F;posts">← Back</a>
  </nav>
</header>


    <div>
      
      
      
      
      <div id="copy-cfg" style="display: none;" data-copy-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;18&quot; height=&quot;18&quot;&gt;&lt;path d=&quot;M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;
" data-check-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;18&quot; height=&quot;18&quot;&gt;&lt;path d=&quot;M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;
"></div>
      
      <article class="prose">
        <h1>Evo 2: Arc’s DNA Foundation Model Explained</h1>
        <div id="post-info">
          <div id="date">
            <span id="publish">Jun 3, 2025</span>
            <span>Updated on <span id="updated">Jun 6, 2025</span></span>
            </div>

          
          
          <div id="stats">
            <span id="reading-time">21 min read</span>
            <span id="word-count">4102 words</span>
          </div>
          

          
          <div id="tags">
            <a class="instant" href="https://ratankaliani.com/tags/bio"><span>#</span>bio</a><a class="instant" href="https://ratankaliani.com/tags/ml"><span>#</span>ml</a>
          </div>
          
        </div>

        
        

        

        <p>In February, <a rel="nofollow noreferrer" href="https://arcinstitute.org/">Arc Institute</a> released <a rel="nofollow noreferrer" href="https://arcinstitute.org/tools/evo">Evo 2</a>, a DNA foundation model trained on genomes from all domains of life. <a rel="nofollow noreferrer" href="https://www.biorxiv.org/content/10.1101/2025.02.18.638918v1">According to Arc</a>, this represents the largest training effort in computational biology to date, with novel architectural advances to handle genomic sequences.</p>
<p>Over the past few decades, synthetic biologists have dreamed of programming cells as easily as we program computers: creating bacteria that clean up pollution, crops that thrive in extreme environments, or therapies that target disease at the genetic level. Traditionally, this has required painstaking manual design and years of trial and error. Evo 2 represents a potential leap forward: what if we could generate entirely new genomes <a rel="nofollow noreferrer" href="https://en.wikipedia.org/wiki/In_silico">in silico</a>, rapidly and at scale?</p>
<p>Over the past few days, I got curious about Evo 2, initially because of the application of a non-Transformer architecture and the nuances of modeling on genomic data. Quickly, I found myself diving through Wikipedia and Deep Research reports to understand the biological concepts and the technical details of Evo 2. This post is a distillation of my understanding of Evo 2, which I hope will be useful to anyone interested in learning more about the intersection of LLMs and biology.</p>
<p>By the end of this post, my goal is for you to understand (1) why genomic sequence modeling can't simply rely on off-the-shelf Transformers, (2) how Evo 2 can be useful in today's biological workflows and (3) how Evo 2 and similar genomic foundation models may evolve in the future.</p>
<h1 id="overview">Overview<a class="zola-anchor" href="#overview" aria-label="Anchor link for: overview" style="visibility: hidden;"></a>
</h1>
<p><img src="/evo2/cover.png" alt="Evo 2 Cover" /></p>
<p>Unlike modern LLMs, which are optimized for the constraints of natural language, Evo 2 is tailored to genomic sequences. From a low-entropy vocabulary to long-range dependencies between tokens &gt;1M tokens apart, modeling genomic sequences is quite different from natural language.</p>
<p>Evo 2 is a successor to <a rel="nofollow noreferrer" href="https://arcinstitute.org/news/blog/evo">Evo</a>, which was the first large genomic language model released by Arc back in early 2024. Evo showed that large, long-context genomic DNA foundation models could viably generate “realistic” genomic sequences. But, Evo only focused on prokaryotes, and didn’t generalize well to human genomes. To accurately predict animal and human genomic sequences, Evo 2 also trained on eukaryotic genomes and modified the architecture of Evo to work for the larger genomes in eukaryotes.</p>
<p>Evo 2 was trained on over 2,000 H100 GPUs for several months, putting the estimated cost of the run at ~$10M. With Evo 2, you can:</p>
<ul>
<li>Generate novel genetic sequences across both eukaryotes and prokaryotes that exhibit high fitness.</li>
<li>Predict the functional impact of specific genetic variants, such as BRCA1 mutations linked to increased breast cancer risk.</li>
<li>Improve sequence‐fitness predictions at inference time: giving the model more compute resources during inference leads to better genomic‐fitness estimates, similar to how test‐time scaling boosts reasoning performance in LLMs.</li>
<li>Handle up to 1 million base pairs of context when generating sequences.</li>
<li>Leverage mechanistic interpretability to see what Evo 2 “learned” from raw genomic data.</li>
</ul>
<p>On paper, Evo 2's capabilities are impressive, but I want to know how Evo 2 <em>really</em> works. Sure, by increasing the dataset size, model size or compute, <a rel="nofollow noreferrer" href="https://arxiv.org/abs/2001.08361">you expect language models to get better</a>. What makes Evo 2 so performant at genomic modeling?</p>
<h1 id="quick-primer">Quick Primer<a class="zola-anchor" href="#quick-primer" aria-label="Anchor link for: quick-primer" style="visibility: hidden;"></a>
</h1>
<p>To make sure that you don’t get overwhelmed by the breadth of biological knowledge to understand Evo 2 and spend several hours asking questions to your favorite reasoning model, I’ve distilled some basic biology concepts relevant for understanding Evo 2 here. These include both the data that Evo 2 is modeled on, and some terms for the tasks that Evo 2 is applied to. If you're already familiar with these concepts, feel free to skip to the <a href="https://ratankaliani.com/posts/evo2/#training-architecture">Training &amp; Architecture</a> section.</p>
<h2 id="genome-modeling">Genome Modeling<a class="zola-anchor" href="#genome-modeling" aria-label="Anchor link for: genome-modeling" style="visibility: hidden;"></a>
</h2>
<h3 id="nucleotide-sequences">Nucleotide Sequences<a class="zola-anchor" href="#nucleotide-sequences" aria-label="Anchor link for: nucleotide-sequences" style="visibility: hidden;"></a>
</h3>
<p>Evo 2 models DNA sequences. These linear sequences are composed of nucleotides that encode genetic information: adenine (A), guanine (G), cytosine (C), and thymine (T). According to the paper, Evo 2 also pre-trains on RNA sequences, and RNA sequences use Uracil (U) instead of Thymine (T). In DNA, this is abbreviated as “AGCT”, and in “RNA” as “AUCG”. I’ll refer to them as nucleotide or genomic sequences throughout the rest of the post.</p>
<h3 id="dna-rna-protein">DNA → RNA → Protein<a class="zola-anchor" href="#dna-rna-protein" aria-label="Anchor link for: dna-rna-protein" style="visibility: hidden;"></a>
</h3>
<p>Evo 2 explicitly models DNA sequences and RNA sequences because it’s pre-trained on them. <em>But how does it model protein sequences?</em> DNA and RNA contain the instructions for protein synthesis, so Evo 2 can learn statistical and structural features of DNA/RNA that implicitly encode proteins. Evo 2 learns which RNA transcripts are likely to be stable, expressed and translated into functional proteins. When I cover mechanistic interpretability with Evo 2, I’ll show specifically how it has internalized these features. This is known as the “<a rel="nofollow noreferrer" href="https://en.wikipedia.org/wiki/Central_dogma_of_molecular_biology">central dogma</a>”, with the caveat that RNA does more than just implicitly encode proteins (<a rel="nofollow noreferrer" href="https://xkcd.com/3056/">obligatory XKCD #3056</a>).</p>
<h3 id="variant-effect-prediction">Variant-Effect Prediction<a class="zola-anchor" href="#variant-effect-prediction" aria-label="Anchor link for: variant-effect-prediction" style="visibility: hidden;"></a>
</h3>
<p>Computational bridge from raw mutation to clinical decision, based on a genetic mutation you can determine if a specific condition is more likely.</p>
<h3 id="snvs">SNVs<a class="zola-anchor" href="#snvs" aria-label="Anchor link for: snvs" style="visibility: hidden;"></a>
</h3>
<p>Single nucleotide variant - a change in a single base in the genome sequence. Most are benign and some are harmful.</p>
<h3 id="variant-pathogenicity">Variant Pathogenicity<a class="zola-anchor" href="#variant-pathogenicity" aria-label="Anchor link for: variant-pathogenicity" style="visibility: hidden;"></a>
</h3>
<p>How likely a genetic variant (usually an SNV) is to cause disease. Falls into 3 categories: pathogenic (causes disease), uncertain significance and benign.</p>
<h2 id="bioml">BioML<a class="zola-anchor" href="#bioml" aria-label="Anchor link for: bioml" style="visibility: hidden;"></a>
</h2>
<p>To contextualize Evo 2, it’s also important to understand the lineage of models that it follows. There are two main model lineages that are relevant to Evo 2, large protein language models, trained on protein sequences, and large genomics models, trained on genomic DNA sequences.</p>
<p><a rel="nofollow noreferrer" href="https://alphafold.ebi.ac.uk/">AlphaFold</a>, one of the first large protein language models (PLMs) came out in 2020 and predicted protein structures. It clearly demonstrated how ML algorithms can “learn” biological structures better than humans for laboratory relevant tasks. Then in 2021, <a rel="nofollow noreferrer" href="https://github.com/facebookresearch/esm">ESMFold</a> demonstrated how the transformer architecture could be applied to protein sequences to predict structural features purely from the embeddings of large-scale PLMs.</p>
<p>Around 2021, most genomics modeling was highly task-specific. Models such as <a rel="nofollow noreferrer" href="https://deepmind.google/discover/blog/predicting-gene-expression-with-ai/">Enformer</a> and <a rel="nofollow noreferrer" href="https://github.com/ramanathanlab/genslm">GenSLM</a> were used for epigenomic signals and microbial genome generation, but didn’t generalize well beyond their training set. In 2024, Evo marked a similar transition to ESMFold, but for genomics data. Evo was the first model to show that a long-context genomic sequence model trained on generic prokaryotic data could yield sequences with high prokaryotic sequence fitness <em>without any task-specific fine-tuning</em>. Evo 2 naturally followed Evo, but with architectural changes to perform well for eukaryotic data.</p>
<p><img src="/evo2/evo2_model_size_comp.png" alt="Evo 2 Model Size" /></p>
<h1 id="training-architecture">Training &amp; Architecture<a class="zola-anchor" href="#training-architecture" aria-label="Anchor link for: training-architecture" style="visibility: hidden;"></a>
</h1>
<p>With this background on the biology and model lineages behind Evo 2, let's dive into what's new and unique about the Evo 2 architecture.</p>
<p>Evo 2 uses a <a rel="nofollow noreferrer" href="https://arxiv.org/abs/2503.01868">“multi-hybrid” architecture</a>, a Transformer-like architecture that performs better for the longer context required for genomic modeling using convolutional operators. In this section, I'll go over the Evo 2 architecture, StripedHyena 2, and Evo 2's training recipe.</p>
<h2 id="architecture-motivations">Architecture Motivations<a class="zola-anchor" href="#architecture-motivations" aria-label="Anchor link for: architecture-motivations" style="visibility: hidden;"></a>
</h2>
<p>The motivations for Evo 2’s architecture are quite different than those for traditional LLMs.</p>
<ol>
<li>The context length required for effective genomic modeling is on the order of millions of base pairs due to long-range dependencies between nucleotides. In large nucleotide sequences, “far-apart” bases can still interact with each other. Nucleotide strands fold in 3-D and folding will pack distant nucleotides side by side. In fact, SNVs can cause conditions such as thumb duplication.</li>
<li>The vocabulary size for Evo 2 is O(10), with most tokens concentrated in the nucleotides for DNA, AGCT, and RNA, AGCU. This is drastically smaller than the vocabulary size in <a rel="nofollow noreferrer" href="https://github.com/openai/tiktoken">modern LLMs, which are typically between 10K to 100K tokens</a>.</li>
<li>Single-nucleotide resolution is critical. To make clinically relevant predictions for SNV’s (among other targets), you need to know exactly which nucleotide changes. Increasing the size of the vocabulary to reduce the context length is a patchwork solution and is untenable for this reason.</li>
</ol>
<p>Traditional transformers that are used for language modeling are not able to effectively handle 1M tokens of context with global long-range dependencies. Most LLMs (e.g. <a rel="nofollow noreferrer" href="https://help.openai.com/en/articles/7102672-how-can-i-access-gpt-4o-and-gpt-4-1-mini">GPT-4o</a>, <a rel="nofollow noreferrer" href="https://www.anthropic.com/claude/sonnet">Claude4</a>) max out at a 200K context window due to the <a rel="nofollow noreferrer" href="https://arxiv.org/pdf/2307.08691">quadratic compute requirement for attention</a>.</p>
<p>Methods of achieving longer-context with transformers such as local + periodic global attention still don’t reduce this compute budget requirement. So, out-of-the-box transformers will be quite expensive for modeling genomic sequences at the scale of millions of tokens. Can we use convolutional operators to do better, while retaining the benefits of transformers?</p>
<h2 id="stripedhyena-2-architecture">StripedHyena 2 Architecture<a class="zola-anchor" href="#stripedhyena-2-architecture" aria-label="Anchor link for: stripedhyena-2-architecture" style="visibility: hidden;"></a>
</h2>
<p>Before explaining Evo 2’s architecture, Striped Hyena 2 (SH2), I’ll explain Striped Hyena 1 (SH1), the architecture for Evo. Striped Hyena is a part of a family of architectures that use convolutional operators to model long-range dependencies in combination with attention.</p>
<p>Speficially, SH1 combines the <a rel="nofollow noreferrer" href="https://arxiv.org/abs/2302.10866">Hyena state-space convolution</a> with self-attention layers. SH1 is similar to <a rel="nofollow noreferrer" href="https://arxiv.org/abs/2312.00752">Mamba</a>, except that SH1 fuses the convolutional operators and attention layers to push more computational efficiency and tighter coupling of local &amp; global features. Mamba’s simple sequential convolution → attention blocks can fit into existing Transformer pipelines, whereas SH1 requires custom fusion logic. Because SH1 is applied to genomic data, where the context length is much longer than in language modeling, this tradeoff makes more sense. Fusing together the attention and convolution blocks amortizes the overhead to reduce inference and training compute, which yields 2x speedup over dense transformers.</p>
<p>Mamba and SH1 are known as “hybrid” architectures because they combine two key components: attention and state-space convolutions.</p>
<p>Evo 2’s architecture, called SH2, builds on this idea by using a mix of attention layers and three types of convolutional operators—short, medium, and long. Each operator is specialized: short convolutions capture local (nearby) dependencies, medium convolutions handle patterns over hundreds of tokens, and long convolutions capture relationships across very long stretches of the sequence. This combination is why SH2 is referred to as a “multi-hybrid” architecture.</p>
<p>A major advantage of SH2 over SH1 is its use of multiple convolutional layers, rather than just Hyena-LI, which increases training and inference speed.  Specifically:</p>
<ul>
<li><strong>Hyena-SE (Short Explicit filters):</strong> Focuses on recalling information from nearby tokens (local context).</li>
<li><strong>Hyena-MR (Medium Regularized filters):</strong> Handles dependencies over several hundred tokens, maintaining efficiency and performance.</li>
<li><strong>Hyena-LI (Long Implicit filters):</strong> Captures long-range dependencies across the sequence.</li>
</ul>
<p>The <a rel="nofollow noreferrer" href="https://arcinstitute.org/manuscripts/Evo2-ML">ML paper for Evo 2</a> draws a nice parallel between the new convolutional operators and the classic attention operator.</p>
<blockquote>
<p>Hyena-MR is to Hyena-LI what sliding window attention is to the classic attention operator.</p>
</blockquote>
<p>By leveraging more efficient convolutional operators for short, local recall, SH2 gets a 2x-3x speedup in training over SH1. SH2 only pays for long-range context occasionally, rather than in each layer.</p>
<p><img src="/evo2/evo1_evo2_architecture.png" alt="Evo 2 Architecture" /></p>
<p>Below, you can see the scaling results for a dense transformer against SH1 and SH2. At longer contexts, you can clearly see that the Hyena-SE and Hyena-MR convolutional kernels out-perform MHA (multi-head attention) as you’re no longer paying the quadratic overhead of attention. The use of Hyena-SE and Hyena-MR kernels increases training and inference throughput.</p>
<p><img src="/evo2/training_speedup_vs_transformer.png" alt="Evo 2 Scaling" /></p>
<p>More details on how the convolutional kernels are implemented + further results can be found in the <a rel="nofollow noreferrer" href="https://www.biorxiv.org/content/10.1101/2025.02.18.638918v1">Evo 2 paper</a> and the <a rel="nofollow noreferrer" href="https://arcinstitute.org/manuscripts/Evo2-ML">sister ML paper</a>.</p>
<p>With this background on the architecture, let's dive into the training data and training recipe for Evo 2.</p>
<h2 id="opengenome2-dataset"><code>OpenGenome2</code> Dataset<a class="zola-anchor" href="#opengenome2-dataset" aria-label="Anchor link for: opengenome2-dataset" style="visibility: hidden;"></a>
</h2>
<p>Evo 2’s training data (called <a rel="nofollow noreferrer" href="https://huggingface.co/datasets/arcinstitute/opengenome2">OpenGenome2</a>) comprises over 9T DNA base pairs spanning all domains of life (bacteria, archaea, eukarya).</p>
<p>To capture both local functional elements and long‑range genomic dependencies, two training phases were employed: an initial “short‑context” pretraining on 8,192‑bp windows enriched for genic regions, followed by a “midtraining” stage that extended context to 1M base pairs, with sequence composition shifted toward whole‑genome samples. By combining these two training phases, Evo 2 achieves single‑nucleotide resolution and the diversity needed to generalize across everything from mitochondrial micro‑genomes to complex eukaryotic chromosomes.</p>
<p><img src="/evo2/training_composition_mix.png" alt="Evo 2 Training Composition" /></p>
<p>As seen in the charts below, the vast majority of FLOPS are applied in pre-training. During pre-training, the model gathers knowledge about biological structure, and mid-training extends this structure from just eukaryotic genes to genomic sequences from the genome data bank.</p>
<p><img src="/evo2/tokens_consumed_training.png" alt="Evo 2 Training Tokens" /></p>
<p>Now that you have a basic understanding of the training data and architecture of Evo 2, let's dive into how to use Evo 2 to generate novel genomic sequences.</p>
<h1 id="generating-genomic-sequences">Generating Genomic Sequences<a class="zola-anchor" href="#generating-genomic-sequences" aria-label="Anchor link for: generating-genomic-sequences" style="visibility: hidden;"></a>
</h1>
<p>Evo 2 can generate new DNA sequences by starting from a short input sequence and predicting what nucleotides come next, one base at a time. Evo 2 can be used to generate novel sequences with no guidance (zero-shot novel generation), or to search for a sequence that meets a specified goal (directed search).</p>
<h2 id="zero-shot-novel-sequences">Zero-Shot Novel Sequences<a class="zola-anchor" href="#zero-shot-novel-sequences" aria-label="Anchor link for: zero-shot-novel-sequences" style="visibility: hidden;"></a>
</h2>
<p>The API for requesting a genomic sequence from Evo 2 is quite simple: pass the input and the number of additional tokens and the model will generate the corresponding nucleotides after the initial sequence.</p>
<pre data-lang="python" class="language-python z-code"><code class="language-python" data-lang="python"><span class="z-source z-python"><span class="z-meta z-qualified-name z-python"><span class="z-meta z-generic-name z-python">dna_seq</span></span> <span class="z-keyword z-operator z-assignment z-python">=</span> <span class="z-meta z-function-call z-python"><span class="z-meta z-qualified-name z-python"><span class="z-meta z-generic-name z-python">evo2_model</span></span><span class="z-meta z-qualified-name z-python"><span class="z-punctuation z-accessor z-dot z-python">.</span></span><span class="z-meta z-qualified-name z-python"><span class="z-variable z-function z-python"><span class="z-meta z-generic-name z-python">sample</span></span></span></span><span class="z-meta z-function-call z-arguments z-python"><span class="z-punctuation z-section z-arguments z-begin z-python">(</span><span class="z-variable z-parameter z-python">prompt</span><span class="z-keyword z-operator z-assignment z-python">=</span><span class="z-meta z-string z-python"><span class="z-string z-quoted z-double z-python"><span class="z-punctuation z-definition z-string z-begin z-python">&quot;</span></span></span><span class="z-meta z-string z-python"><span class="z-string z-quoted z-double z-python">ATGCTG<span class="z-punctuation z-definition z-string z-end z-python">&quot;</span></span></span><span class="z-punctuation z-separator z-arguments z-python">,</span> <span class="z-constant z-language z-python">...</span><span class="z-punctuation z-separator z-arguments z-python">,</span> <span class="z-variable z-parameter z-python">number_of_tokens</span><span class="z-keyword z-operator z-assignment z-python">=</span><span class="z-constant z-numeric z-integer z-decimal z-python">1000</span><span class="z-punctuation z-section z-arguments z-end z-python">)</span></span>
</span></code></pre>
<p>To demonstrate how Evo 2 generates “novel” genomic sequences and generalizes well, the Evo 2 team generated a diverse set of “viable” eukaryotic genomes starting from a human mitochondrial sequence.</p>
<p>Using <a rel="nofollow noreferrer" href="https://en.wikipedia.org/wiki/BLAST_(biotechnology)">BLAST</a> analysis, they verified that the generated mitochondrial DNA sequences were similar to naturally occurring organisms. Then, with <a rel="nofollow noreferrer" href="https://alphafold.ebi.ac.uk/">AlphaFold 3</a>, they validated that the generated structures matched expected mitochondrial protein complex folds. In simpler terms, scientists check that both the “sequence” and the encoded proteins from the sequence are “viable”.</p>
<p>Below is a sample of how the Evo 2 model was used to generate a set of genomes from a small human mitochondrial DNA seed. The generated genomes ranged from being most similar to a sheep or a fish, all from the same human mitochondrial seed.</p>
<p><img src="/evo2/diverse_genome.png" alt="Diverse Genomes from Human Base" /></p>
<p>As you can see, the generated sequences are quite diverse, and have some measure of biological viability. Designing "natural-looking" genomic sequences is cool, but not what you'd do if you wanted to create a new organism. How can you get a sequence that meets a specific goal - say a sequence that's more likely to bind to a protein target?</p>
<h2 id="scaling-inference-time-compute">Scaling Inference-Time Compute<a class="zola-anchor" href="#scaling-inference-time-compute" aria-label="Anchor link for: scaling-inference-time-compute" style="visibility: hidden;"></a>
</h2>
<p>Unlike traditional LLMs which can be prompted with additional language context to steer the output of generation, Evo 2 can only process nucleotide sequences as input. Once you’ve generated a genome, there’s no way to guide the model in a specific direction with natural language.</p>
<p>So, how do you do directed search for nucleotide sequences that have specific conditions beyond “natural viability” at inference-time?</p>
<p>For this, we can look to modern ML, where scaling inference-time compute has been <a rel="nofollow noreferrer" href="https://arxiv.org/pdf/2501.12948">widely</a> <a rel="nofollow noreferrer" href="https://openai.com/o1/">adopted</a> over the past year. At a high level, techniques for <a rel="nofollow noreferrer" href="https://huggingface.co/spaces/HuggingFaceH4/blogpost-scaling-test-time-compute">scaling inference-time compute</a> can be broadly categorized into <strong>self-refinement</strong> and <strong>searching against a verifier</strong>.</p>
<p>In genomic sequence generation, there are many heuristics (known and unknown) that you may want to optimize a sequence for. This is in contrast to language models, where "more intelligent" answers is generally a 1-dimensional metric to optimize for. To handle this complexity, the Evo 2 team chose to demonstrate searching against a verifier with beam search in their paper, which can be easily adapted to other heuristics.</p>
<p>Beam search is a method for generating sequences where, at each step, you generate N possible candidates from the current sequence. Each candidate is scored using a heuristic function that measures how well it meets the desired criteria. Out of all the candidates, you keep only the top K sequences with the highest scores. This process repeats for each new step, always expanding and selecting the best K options, until the full sequence is generated.</p>
<p><img src="/evo2/beam_search.gif" alt="Beam Search" /></p>
<p>Let’s walk through how the Evo 2 team uses beam search to generate proteins for a specific heuristic: <em>chromatin accessibility</em> patterns. Chromatin accessibility refers to how “open” or “closed” regions of DNA are.</p>
<p>Evo 2 uses <a rel="nofollow noreferrer" href="https://www.nature.com/articles/s41592-021-01252-x">Enformer</a> and <a rel="nofollow noreferrer" href="https://www.biorxiv.org/content/10.1101/2023.08.30.555582v1">Borzoi</a> as heuristic functions for evaluating a generated sequence. Both models yield whether a nucleotide will have accessible chromatin given a window of nucleotides around the target. With beam search, Evo 2 guides the generated genomic sequence to encode specific chromatin accessibility patterns in nucleotides with the following protocol:</p>
<ol>
<li>Sample N times (fan-out) from Evo 2 given the same prompt.</li>
<li>Score the N samples with Enformer and Borzoi.</li>
<li>Select the top K sequences based on their scores and use them as the starting point for the next generation step.</li>
<li>Repeat until you’ve generated a nucleotide sequence of length L.</li>
</ol>
<p>With this approach, the Evo 2 team was able to generate genomic sequences that encode chromatin accessibility patterns that match the Morse code encoding of “Evo 2” and “ARC”. You can see these encoded in the chromatin accessibility diagrams below.</p>
<p><img src="/evo2/chromatin_message.png" alt="Chromatin accessibility" /></p>
<p>By scaling inference-time compute, the Evo 2 team demonstrated how to steer the generation of a sequence to meet a specific heuristic function. Scaling inference-time compute is powerful for guiding sequence generation, but ultimately, the diversity of genomes Evo 2 can produce is bounded by what the model has learned.</p>
<h1 id="evo-2-mechanistic-interpretability">Evo 2 + Mechanistic Interpretability<a class="zola-anchor" href="#evo-2-mechanistic-interpretability" aria-label="Anchor link for: evo-2-mechanistic-interpretability" style="visibility: hidden;"></a>
</h1>
<p><a rel="nofollow noreferrer" href="https://www.transformer-circuits.pub/2022/mech-interp-essay">Mechanistic interpretability</a> can help reveal the underlying biological concepts and genomic features that Evo 2 is capable of generating.</p>
<p>The Evo 2 team worked closely with <a rel="nofollow noreferrer" href="https://www.goodfire.ai/">Goodfire</a> to train <a rel="nofollow noreferrer" href="https://adamkarvonen.github.io/machine_learning/2024/06/11/sae-intuitions.html">sparse auto-encoders (SAEs)</a> to uncover the latent concept representations within Evo 2. SAE's trained on Evo 2 uncover several biologically relevant features, purely from nucleotide sequences:</p>
<ul>
<li>Canonical gene structures (CDS, UTRs, exons).</li>
<li>Structural motifs (α-helices, RNA stem-loops).</li>
<li>Protein structure characteristics</li>
</ul>
<p>How can we use these features to steer the generation of a sequence?</p>
<h2 id="steering-genomic-generation-with-features">Steering Genomic Generation with Features<a class="zola-anchor" href="#steering-genomic-generation-with-features" aria-label="Anchor link for: steering-genomic-generation-with-features" style="visibility: hidden;"></a>
</h2>
<p>In the previous section, we saw how to steer the generation of a sequence to meet a specific heuristic function. But what if there isn’t a well-defined characteristic? What if we just want to explore the space around a generated genomic sequence to see if we can get a sequence that fits our constraints?</p>
<p>In general, the decision space for guiding outputs of a large model is limited to: prompt engineering, inference-time compute scaling, training models to seek specific characteristics with rewards (RL) or <a rel="nofollow noreferrer" href="https://aarnphm.xyz/thoughts/mechanistic-interpretability#steering">steering</a>.</p>
<p>From <a rel="nofollow noreferrer" href="https://www.goodfire.ai/blog/interpreting-evo-2">Goodfire’s blog on Evo 2</a>:</p>
<blockquote>
<p>Unlike language models that process human-readable text, these neural networks operate on DNA sequences—a biological code that even human experts struggle to directly read and understand</p>
</blockquote>
<blockquote>
<p>The potential impact of steering Evo 2 is particularly significant: while language models can be prompted to achieve desired behaviors, a model that 'only speaks nucleotide' cannot. Learning to steer through features would unlock entirely new capabilities.</p>
</blockquote>
<p>In Evo 2, there is no equivalent to prompt engineering because the model only understands genetic sequences. Of the other three, steering is the only category that does not require inference-time compute to scale. Rather, steering can be used to directly guide sequences towards having characteristics in the latent space of DNA without requiring an explicit heuristic function.</p>
<p>Especially when exploring the space around a generated sequence, steering is a powerful tool. Unfortunately, the Evo 2 team did not provide a way to steer the generation of a sequence, though the Goodfire team hints at future work in this direction.</p>
<blockquote>
<p>Preliminary experiments have shown promising directions for steering these features to guide DNA sequence generation, though this work is still in its early stages.</p>
</blockquote>
<p>Even without such a tool, we can still visualize the features that Evo 2 has learned to get a sense of what future support for steering might look like.</p>
<h2 id="visualizing-evo-2-s-latent-space-with-feature-activations">Visualizing Evo 2's Latent Space with Feature Activations<a class="zola-anchor" href="#visualizing-evo-2-s-latent-space-with-feature-activations" aria-label="Anchor link for: visualizing-evo-2-s-latent-space-with-feature-activations" style="visibility: hidden;"></a>
</h2>
<p>Goodfire’s <a rel="nofollow noreferrer" href="https://arcinstitute.org/tools/evo/evo-mech-interp">mechanistic interpretability visualizer for Evo 2</a> annotates feature activations on genomic sequences.</p>
<p>In the image below, you can see the feature activations for the <code>Haemophilus influenzae</code> genome (the common cause of many infections). At different levels of granularity, you can see the activations for α-helices and β-sheets, as well as those at the RNA-level, such as ribosomal RNA.</p>
<p><img src="/evo2/mech_interp_visualizer.png" alt="Mechanistic Interpretability Visualizer" /></p>
<p>Using AlphaFold3, you can model the 3D protein structure for a nucleotide sequence. You can see in the image below that the the positional pattern of the features matches the simulated secondary-structure elements of the encoded “protein”. This is one of the cooler representations of how genomic language models “learn” the 3-D structure of proteins, without being explicitly trained on them.</p>
<p><img src="/evo2/protein_structure_annotated.png" alt="Annotated protein structure" /></p>
<p>Although all of the identified features above from Evo 2 are biological features which are commonplace in literature, mechanistic interpretability could discover learned representations of unknown biological features not yet documented in scientific literature. If large models can learn “deeper representations” beyond what’s known in literature, simply training a model and interpreting it could be enough to unlock new research.</p>
<h1 id="takeaways">Takeaways<a class="zola-anchor" href="#takeaways" aria-label="Anchor link for: takeaways" style="visibility: hidden;"></a>
</h1>
<p>At this point, you've learned about the architecture behind Evo 2, how it can be used to generate novel genomic sequences and how Evo 2 could identify features in the latent space of DNA. What I haven't discussed is the future of Evo 2 and where biologists will use the model.</p>
<p>To get a sense of the limitations and potential of Evo 2, I'd recommend reading <a rel="nofollow noreferrer" href="https://x.com/owl_posting">owlposting</a>'s <a rel="nofollow noreferrer" href="https://www.owlposting.com/p/a-socratic-dialogue-over-the-utility">socratic</a> <a rel="nofollow noreferrer" href="https://www.owlposting.com/p/a-socratic-dialogue-over-the-utility-a78">dialogue</a> on Evo 2. I generally agree with owlposting's high-level assessments:</p>
<ul>
<li>Evo 2 needs wet-lab validation for pathogenicity prediction to be used in production workflows, because it was only evaluated with digital models, not on any biological experiments.</li>
<li>High-fidelity genome generation at scale is only possible with large models such as Evo 2, not through manual human design. But the utility today is bottlenecked by DNA synthesis costs.</li>
</ul>
<p>LLMs today are useful for real-world tasks because reward models for language can already be approximated at a reasonable cost. This has been shown with RLHF for qualitative reasoning tasks and specific RL reward models for tasks such as math and coding. On the other hand, DNA foundation models like Evo 2 don’t have access to the same quantity of high fidelity data. Getting reward signals from biological systems is difficult because you need to run experiments <em>over days or weeks</em>, which can't be accelerated by just adding more compute. To create useful RL environments for Evo 2, you need to integrate with high-throughput biological systems. To accelerate biological research with Evo 2, we’ll need better virtual environments for training, tighter integration with high-throughput experiments, and reward modeling that bridges the computational-to-experimental gap.</p>
<p>Though Evo 2 is a step in the right direction towards an <a rel="nofollow noreferrer" href="https://www.sequoiacap.com/podcast/training-data-patrick-hsu/">"App Store for Biology"</a>, a clear bottleneck in applying these models is the challenges of wet-lab biological validation. Unlike software, where closed-loop feedback and rapid iteration are possible, biological research is constrained by the cost and complexity of experiments and data collection. Progress with Evo 2 and other models will depend as much on building better experimental and data infrastructure as on advances in model design.</p>
<p><em>Thanks to <a rel="nofollow noreferrer" href="https://x.com/chriswzou">Chris Zou</a> and <a rel="nofollow noreferrer" href="https://x.com/daryakaviani">Darya Kaviani</a> for their feedback &amp; support on this post! I appreciated Asimov's <a rel="nofollow noreferrer" href="https://www.asimov.press/p/evo-2">post on Evo 2</a> and owlposting's <a rel="nofollow noreferrer" href="https://www.owlposting.com/p/a-socratic-dialogue-over-the-utility">socratic dialogues</a>, which were both an inspiration for this post.</em></p>

      </article>

      
      

      
      
    </div>

    


<footer>
  <div class="left">
    <div class="copyright">
      © 2025 Ratan Kaliani
      
    </div>
  </div>

  <div class="right">
    
    
      
    
    
    <a id="rss-btn" href="https://ratankaliani.com/posts/feed.xml">RSS</a>
    
    

    
    
    
    <button id="theme-toggle" aria-label="theme switch">
      <span class="moon-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18"><path d="M10 7C10 10.866 13.134 14 17 14C18.9584 14 20.729 13.1957 21.9995 11.8995C22 11.933 22 11.9665 22 12C22 17.5228 17.5228 22 12 22C6.47715 22 2 17.5228 2 12C2 6.47715 6.47715 2 12 2C12.0335 2 12.067 2 12.1005 2.00049C10.8043 3.27098 10 5.04157 10 7ZM4 12C4 16.4183 7.58172 20 12 20C15.0583 20 17.7158 18.2839 19.062 15.7621C18.3945 15.9187 17.7035 16 17 16C12.0294 16 8 11.9706 8 7C8 6.29648 8.08133 5.60547 8.2379 4.938C5.71611 6.28423 4 8.9417 4 12Z" fill="currentColor"></path></svg>
</span>
      <span class="sun-icon"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18"><path d="M12 18C8.68629 18 6 15.3137 6 12C6 8.68629 8.68629 6 12 6C15.3137 6 18 8.68629 18 12C18 15.3137 15.3137 18 12 18ZM12 16C14.2091 16 16 14.2091 16 12C16 9.79086 14.2091 8 12 8C9.79086 8 8 9.79086 8 12C8 14.2091 9.79086 16 12 16ZM11 1H13V4H11V1ZM11 20H13V23H11V20ZM3.51472 4.92893L4.92893 3.51472L7.05025 5.63604L5.63604 7.05025L3.51472 4.92893ZM16.9497 18.364L18.364 16.9497L20.4853 19.0711L19.0711 20.4853L16.9497 18.364ZM19.0711 3.51472L20.4853 4.92893L18.364 7.05025L16.9497 5.63604L19.0711 3.51472ZM5.63604 16.9497L7.05025 18.364L4.92893 20.4853L3.51472 19.0711L5.63604 16.9497ZM23 11V13H20V11H23ZM4 11V13H1V11H4Z" fill="currentColor"></path></svg>
</span>
    </button>
    
  </div>
</footer>




<dialog id="rss-mask">
  <div>
    <a href="https:&#x2F;&#x2F;ratankaliani.com&#x2F;posts&#x2F;feed.xml">https:&#x2F;&#x2F;ratankaliani.com&#x2F;posts&#x2F;feed.xml</a>
    
    
    <button autofocus aria-label="copy" data-link="https:&#x2F;&#x2F;ratankaliani.com&#x2F;posts&#x2F;feed.xml" data-copy-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;18&quot; height=&quot;18&quot;&gt;&lt;path d=&quot;M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;
" data-check-icon="&lt;svg xmlns=&quot;http:&#x2F;&#x2F;www.w3.org&#x2F;2000&#x2F;svg&quot; viewBox=&quot;0 0 24 24&quot; width=&quot;18&quot; height=&quot;18&quot;&gt;&lt;path d=&quot;M10.0007 15.1709L19.1931 5.97852L20.6073 7.39273L10.0007 17.9993L3.63672 11.6354L5.05093 10.2212L10.0007 15.1709Z&quot; fill=&quot;currentColor&quot;&gt;&lt;&#x2F;path&gt;&lt;&#x2F;svg&gt;
" >
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" width="18" height="18"><path d="M6.9998 6V3C6.9998 2.44772 7.44752 2 7.9998 2H19.9998C20.5521 2 20.9998 2.44772 20.9998 3V17C20.9998 17.5523 20.5521 18 19.9998 18H16.9998V20.9991C16.9998 21.5519 16.5499 22 15.993 22H4.00666C3.45059 22 3 21.5554 3 20.9991L3.0026 7.00087C3.0027 6.44811 3.45264 6 4.00942 6H6.9998ZM5.00242 8L5.00019 20H14.9998V8H5.00242ZM8.9998 6H16.9998V16H18.9998V4H8.9998V6Z" fill="currentColor"></path></svg>

    </button>
  </div>
</dialog>



  </main>
</div>

  
<script src="/js/lightense.min.js"></script>


  <script src="https://ratankaliani.com/js/main.js"></script>
</body>

</html>
